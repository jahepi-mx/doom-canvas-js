<html>

<head>
<title>Test</title>
<meta charset="UTF-8">
<script src="vector.js"></script>
<script src="line.js"></script>
<script src="player.js"></script>
<script>
var w = 500;
var h = 500;
var hw = w * 0.5;
var hh = h * 0.5;
var canvas = null;
var context = null;
var localCanvas = null;
var localContext = null;
var canvas3d = null;
var context3d = null;
var lastTime = 0;
var player = null;
var lines = [];
var width3d = 400;
var height3d = 400;
var hw3d = width3d * 0.5;
var hh3d = height3d * 0.5;

//Perpective
var tan = 0;
var camZOffset = new Vector(0, 0);

window.onload = function() {
    canvas = document.getElementById("canvas");
    context = canvas.getContext("2d");
    canvas.width = w;
    canvas.height = h;
    localCanvas = document.getElementById("localCanvas");
    localContext = localCanvas.getContext("2d");
    localCanvas.width = w;
    localCanvas.height = h;
    canvas3d = document.getElementById("3dCanvas");
    context3d = canvas3d.getContext("2d");
    canvas3d.width = width3d;
    canvas3d.height = height3d;
    player = new Player(hw, hh);

    lines.push(new Line(hw, hh, -141.42, 141.42, -100, 250, "yellow", player));
    lines.push(new Line(hw, hh, -100, 250, 0, 200, "yellow", player));

    lines.push(new Line(hw, hh, -141.42, 141.42, 0, 200, "yellow", player));
    lines.push(new Line(hw, hh, 0, 200, 141.42, 141.42, "blue", player));
    lines.push(new Line(hw, hh, 141.42, 141.42, 200, 0, "red", player));
    lines.push(new Line(hw, hh, 200, 0, 141.42, -141.42, "brown", player));
    lines.push(new Line(hw, hh, 141.42, -141.42, 0, -200, "green", player));
    lines.push(new Line(hw, hh,  0, -200, -141.42, -141.42, "pink", player));
    lines.push(new Line(hw, hh, -141.42, -141.42, -200, 0, "white", player));
    lines.push(new Line(hw, hh, -200, 0, -141.42, 141.42, "orange", player));

    tan = 1 / Math.tan(player.fovDegrees * player.toRadians);
    camZOffset.z = 0;

    document.onkeydown = onKeyDown;
    document.onkeyup = onKeyUp;
    render();
}
        
function onKeyDown(key) {
    switch(key.keyCode) {
        case 65: player.left = true; break;
        case 68: player.right = true; break;
        case 87: player.up = true; break;
    }
}

function onKeyUp(key) {
    switch(key.keyCode) {
        case 65: player.left = false; break;
        case 68: player.right = false; break;
        case 87: player.up = false; break;
    }
}

function render(time) {
    var dt = (time - lastTime) / 1000;
    var fps = 1 / dt;
    //console.log(fps);
    context.imageSmoothingEnabled = false;
    context.clearRect(0, 0, w, h);
    localContext.imageSmoothingEnabled = false;
    localContext.clearRect(0, 0, w, h);
    context3d.imageSmoothingEnabled = false;
    context3d.clearRect(0, 0, width3d, height3d);
    lastTime = time;

    if (fps < 3) {
        requestAnimationFrame(render);
        return;
    }

    player.update(dt);
    player.render(context);
    player.localRender(localContext);
    var zBuffer = [];
    for (let line of lines) {
        line.update(dt)
        line.render(context);
        line.localRender(localContext);
        
        if (line.hasIntersectionPoints()) {
            localContext.fillStyle = "white";
            localContext.fillRect(hw + line.intersectA.x - 3, hh - (line.intersectA.y + 3), 6, 6);
            localContext.fillRect(hw + line.intersectB.x - 3, hh - (line.intersectB.y + 3), 6, 6);

            // Camera Z offset
            line.intersectA.z -= camZOffset.z;
            line.intersectB.z -= camZOffset.z;

            var sxAUp = line.intersectA.x * (1 / line.intersectA.y) * tan * hw3d;
            var szAUp = (line.intersectA.z + line.height * 0.5) * (1 / line.intersectA.y) * tan * hh3d;
            var sxBUp = line.intersectB.x * (1 / line.intersectB.y) * tan * hw3d;
            var szBUp = (line.intersectB.z + line.height * 0.5) * (1 / line.intersectB.y) * tan * hh3d;

            var sxADown = line.intersectA.x * (1 / line.intersectA.y) * tan * hw3d;
            var szADown = (line.intersectA.z - line.height * 0.5) * (1 / line.intersectA.y) * tan * hh3d;
            var sxBDown = line.intersectB.x * (1 / line.intersectB.y) * tan * hw3d;
            var szBDown = (line.intersectB.z - line.height * 0.5) * (1 / line.intersectB.y) * tan * hh3d;

            context3d.beginPath();
            context3d.moveTo(hw3d + sxADown, hh3d - szADown);
            context3d.lineTo(hw3d + sxBDown, hh3d - szBDown);
            context3d.lineWidth = 3;
            context3d.strokeStyle = 'white';
            context3d.stroke();

            context3d.beginPath();
            context3d.moveTo(hw3d + sxAUp, hh3d - szAUp);
            context3d.lineTo(hw3d + sxBUp, hh3d - szBUp);
            context3d.lineWidth = 3;
            context3d.strokeStyle = 'white';
            context3d.stroke();

            context3d.beginPath();
            context3d.moveTo(hw3d + sxADown, hh3d - szADown);
            context3d.lineTo(hw3d + sxAUp, hh3d - szAUp);
            context3d.lineWidth = 3;
            context3d.strokeStyle = 'white';
            context3d.stroke();

            context3d.beginPath();
            context3d.moveTo(hw3d + sxBDown, hh3d - szBDown);
            context3d.lineTo(hw3d + sxBUp, hh3d - szBUp);
            context3d.lineWidth = 3;
            context3d.strokeStyle = 'white';
            context3d.stroke();

            /*
            var ratioA = player.fovCenter.localPosition1.y / line.intersectA.y;
            var ratioB = player.fovCenter.localPosition1.y / line.intersectB.y;
            var xA = line.intersectA.x * ratioA + player.fovCenter.len * 0.5;
            var xB = line.intersectB.x * ratioB + player.fovCenter.len * 0.5;
            var xScreenA = xA / player.fovCenter.len * width3d;
            var xScreenB = xB / player.fovCenter.len * width3d;
            
            var min = xScreenA;
            var left = line.intersectA;
            var max = xScreenB;
            var right = line.intersectB;
            if (xScreenA > xScreenB) {
                min = xScreenB;
                left = line.intersectB;
                max = xScreenA;
                right = line.intersectA;
            }
            
            var xDiff = right.x - left.x;
            var yDiff = right.y - left.y;

            var h1 = (100 / (100 + left.y)) * height3d; 
            var h2 = (100 / (100 + right.y)) * height3d;
            
            var hwid = 2;
            var diffh = h2 - h1;
            var diffz = right.y - left.y;
            for (var sx = min; sx <= max; sx += hwid) {
                var ratio = (sx - min) / (max - min);
                var height = h1 + diffh * ratio;
                var z = left.y + diffz * ratio;
                zBuffer.push({'height': height, 'x':sx, 'z': z, 'color': line.color, 'width': hwid});
            }*/
        }
    }
    /*
    context3d.fillStyle = '#87ceeb';
    context3d.fillRect(0, 0, width3d, height3d * 0.5);
    context3d.fillStyle = 'gray';
    context3d.fillRect(0, height3d * 0.5, width3d, height3d * 0.5);

    zBuffer.sort((a, b) => b.z - a.z);
    for (let obj of zBuffer) {
        context3d.fillStyle = obj.color;
        context3d.fillRect(obj.x, height3d * 0.5 - obj.height * 0.5, obj.width + 1, obj.height);
    }
        */
    requestAnimationFrame(render)
}
</script>

</head>
<body>

<canvas id="canvas" style="background-color: black;"></canvas>
<canvas id="localCanvas" style="background-color: black;"></canvas>
<canvas id="3dCanvas" style="background-color: black;"></canvas>

</body>
</html>